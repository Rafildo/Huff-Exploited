typedef struct Heap {
    Huff_Node **array;
    int size;
} Heap;

Heap* Create_Heap(int size) {
    Heap *new_heap = (Heap*) malloc(sizeof(Heap));
    new_heap->array = (Huff_Node**) malloc(size * sizeof(Huff_Node*));
    for(int i = 1; i <= size; i++) new_heap->array[i] = NULL;
    new_heap->size = 0;
    return new_heap;
}

int Get_Data(Heap *heap, int index) {
    return heap->array[index]->data;
}

int Get_Frequency(Heap *heap, int index) {
    return heap->array[index]->frequency;
}

int Get_Left(int index) {
    return (index << 1);
}

int Get_Right(int index) {
    return ((index << 1) + 1);
}

int Get_Parent(int index) {
    return (index >> 1);
}

void swap(Heap *heap, int i, int j) {
    Huff_Node *aux = heap->array[i];
    heap->array[i] = heap->array[j];
    heap->array[j] = aux;
    return;
}

void Insert_Heap(Heap *heap, Huff_Node *node) {
    heap->array[++heap->size] = node;
    int current = heap->size;
    int parent = Get_Parent(heap->size);
    while(parent >= 1 &&
            (Get_Frequency(heap, current) < Get_Frequency(heap, parent) ||
             (Get_Frequency(heap, current) == Get_Frequency(heap, parent) &&
              Get_Data(heap, current) == '*')) {
        swap(heap, parent, current);
        current = parent;
        parent = Get_Parent(parent);
    }
    return;
}

void Min_Heapfy(Heap *heap, int index) {
    int least = index;
    int left = Get_Left(index);
    int right = Get_Right (index);

    if(left <= heap->size) {
        if(Get_Frequency(heap, least) > Get_Frequency(heap, left) ||
            (Get_Frequency(heap, least) == Get_Frequency(heap, left) &&
                Get_Data(heap, left) == '*')) {
            least = left;
        }
    }

    if(right <= heap->size) {
        if(Get_Frequency(heap, least) > Get_Frequency(heap, right) ||
            (Get_Frequency(heap, least) == Get_Frequency(heap, right) &&
                Get_Data(heap, right) == '*') {
            least = right;
        }
    }

    if(index != least) {
        swap(heap, index);
        Min_Heap(heap, least);
    }
    return;
}

