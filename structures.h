#ifndef STRUCTURES.H
#define STRUCTURES.H

typedef struct node
{
	unsigned char item;
	int q;
	int flag;
	struct node *left;
	struct node *right;
	struct node *next;
}node;

typedef struct pq
{
	node *head;
}pq;

pq *create_pq()
{
	pq *new_pq = (pq*) malloc(sizeof(pq));
	new_pq->head = NULL;
	return new_pq;
}
node *create_empty_node()
{
	return NULL;
}

node *create_node(unsigned char l, int q)
{
	node *new_node = (node*) malloc(sizeof(node));
	new_node->item = l;
	new_node->q = q;
	new_node->left = NULL;
	new_node->right = NULL;
	new_node->next = NULL;
	return new_node;
}

node *create_tree_node(unsigned char item, int q, node *left, node *right)
{
	node *new_node = (node*) malloc(sizeof(node));
	new_node->item = item;
	new_node->q = q;
	new_node->left = left;
	new_node->right = right;
	new_node->flag = 0;
	return new_node;
}

node *add(node *head,unsigned char item)
{
	if(head!=NULL)
	{
		if (head->item == item)
		{
			head->q++;
			return head;
		}
		head->next = add(head->next,item);
		return head;
	}

	node *new_node = malloc(sizeof(node));
	new_node->item = item;
	new_node->q = 1;
	new_node->next = NULL;
	return new_node;
}

void enqueue(pq *queue, node *head)
{
		node *new_node = (node*) malloc(sizeof(node));
		new_node->item = head->item;
		new_node->q = head->q;
		if (queue->head == NULL ||(head->q < queue->head->q))
		{
				new_node->next = queue->head;
				queue->head = new_node;
		}
		else
		{
			node *temp = queue->head;
			while((temp->next != NULL) && (temp->next->q < head->q))
			{
				temp = temp->next;
			}
				new_node->next = temp->next;
				temp->next = new_node;
		}
}

void enqueue_tree(pq *queue, node *head,node*left,node *right)
{
		node *new_node = create_tree_node(head->item,head->q,left,right);
		if (queue->head == NULL ||(head->q < queue->head->q))
		{
				new_node->next = queue->head;
				queue->head = new_node;
		}
		else if (head->q == queue->head->q)
		{
			if (head->item == '*')
			{
				new_node->next = queue->head;
				queue->head = new_node;
			}
		}
		else
		{
			node *temp = queue->head;
			while((temp->next != NULL) && (temp->next->q < head->q))
			{
				temp = temp->next;
			}
				new_node->next = temp->next;
				temp->next = new_node;
		}
}

node *dequeue(pq *queue)
{
	if (queue->head != NULL)
	{
		node *temp = queue->head;
		queue->head = queue->head->next;
		return temp;
	}
	return 0;
}

void merge(node *bt,node *left, node *right,pq *queue)
{
	bt = create_node('*', left->q + right->q);
	bt->left = left;
	bt->right = right;
	enqueue_tree(queue,bt,bt->left,bt->right);
}

void print(node *head)
{
	node *temp = head;
	while(temp != NULL)
	{
		printf("%c %d\n",temp->item,temp->q);
		temp = temp->next;
	}
}

void print_tree(node *head)
{
	if(head != NULL)
	{
		printf("%c",head->item);
		print_tree(head->left);
		print_tree(head->right);
	}
}

#endif
